<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>CSS Pro Interpreter - Markdown Output Edition</title>
    <style>
        :root { --bg: #f8fafc; --accent: #2563eb; --text: #1e293b; }
        body { font-family: "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; background: var(--bg); color: var(--text); padding: 20px; }
        .container { max-width: 1000px; margin: 0 auto; background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); }
        h2 { font-size: 1.1rem; border-left: 4px solid var(--accent); padding-left: 10px; margin: 20px 0 10px; }
        textarea { width: 100%; padding: 15px; border: 2px solid #cbd5e1; border-radius: 8px; font-family: monospace; font-size: 13px; box-sizing: border-box; }
        #cssInput { height: 120px; margin-bottom: 10px; }
        #mdOutput { height: 500px; background: #f1f5f9; }
    </style>
</head>
<body>
<div class="container">
    <h1>üé® CSS Professional Interpreter (MD)</h1>
    
    <h2>1. CSS Input</h2>
    <textarea id="cssInput" placeholder="Ëß£Êûê„Åó„Åü„ÅÑCSS„ÇíË≤º„Çä‰ªò„Åë„Å¶„Åè„Å†„Åï„ÅÑ..."></textarea>
    
    <h2>2. Markdown Report Output</h2>
    <textarea id="mdOutput" readonly placeholder="„Åì„Åì„Å´Ëß£ÊûêÁµêÊûú„ÅåMarkdownÂΩ¢Âºè„ÅßÁîüÊàê„Åï„Çå„Åæ„Åô..."></textarea>
</div>

<script>
    // --- ÂÖ®Ëâ≤Ëß£Êûê„Ç®„É≥„Ç∏„É≥„ÅÆÂÆåÂÖ®ÁßªÊ§ç ---
    function getColorName(colorStr) {
        if (!colorStr) return "";
        const ctx = document.createElement('canvas').getContext('2d');
        ctx.fillStyle = colorStr;
        const computed = ctx.fillStyle; 

        if (colorStr.includes('var(')) {
            const varMatch = colorStr.match(/var\(([^)]+)\)/);
            return `Â§âÊï∞ \`${varMatch ? varMatch[1] : 'unknown'}\``;
        }
        if (colorStr === 'transparent') return "ÈÄèÊòé";

        let r, g, b;
        if (computed.startsWith('#')) {
            r = parseInt(computed.slice(1, 3), 16);
            g = parseInt(computed.slice(3, 5), 16);
            b = parseInt(computed.slice(5, 7), 16);
        } else {
            const match = computed.match(/\d+/g);
            if (!match) return colorStr;
            [r, g, b] = match.map(Number);
        }

        let r_n = r / 255, g_n = g / 255, b_n = b / 255;
        let max = Math.max(r_n, g_n, b_n), min = Math.min(r_n, g_n, b_n);
        let h, s, l = (max + min) / 2;

        if (max === min) h = s = 0;
        else {
            let d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r_n: h = (g_n - b_n) / d + (g_n < b_n ? 6 : 0); break;
                case g_n: h = (b_n - r_n) / d + 2; break;
                case b_n: h = (r_n - g_n) / d + 4; break;
            }
            h /= 6;
        }

        const hue = h * 360;
        const sat = s * 100;
        const light = l * 100;

        let colorName = "„Ç∞„É¨„ÉºÁ≥ª„ÅÆËâ≤";
        if (sat < 10) {
            if (light > 95) return "ÁôΩ";
            if (light < 10) return "Èªí";
            colorName = "ÁÅ∞Ëâ≤";
        } else {
            if (hue < 20 || hue > 340) colorName = "Ëµ§Ëâ≤";
            else if (hue < 45) colorName = "„Ç™„É¨„É≥„Ç∏Ëâ≤";
            else if (hue < 75) colorName = "ÈªÑËâ≤";
            else if (hue < 160) colorName = "Á∑ëËâ≤";
            else if (hue < 190) colorName = "Ê∞¥Ëâ≤";
            else if (hue < 260) colorName = "ÈùíËâ≤";
            else if (hue < 300) colorName = "Á¥´Ëâ≤";
            else colorName = "„Éî„É≥„ÇØËâ≤";
        }

        let nuance = "";
        if (light > 85) nuance = "ÁôΩ„Åø„Åå„Åã„Å£„Åü";
        else if (light < 25) nuance = "Êöó„ÅÑ";
        else if (sat > 85) nuance = "ÈÆÆ„ÇÑ„Åã„Å™";
        else if (sat < 35) nuance = "Êéß„Åà„ÇÅ„Å™";

        return `${nuance}${colorName}`;
    }

    // --- ÂÖ®ËæûÊõ∏„Éá„Éº„Çø„ÅÆÂÆåÂÖ®ÁßªÊ§ç ---
    const dict = {
        'display': v => v === 'none' ? "ÈùûË°®Á§∫„Å®Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ" : v === 'flex' ? "Áúü„Çì‰∏≠„Çà„ÅõÊ®™‰∏¶„Å≥„ÅßË°®Á§∫„Åï„Çå„Çã„É¨„Ç§„Ç¢„Ç¶„Éà„Åß„Åô„ÄÇ" : `Ë°®Á§∫ÂΩ¢Âºè„ÅØ **${v}** „Åß„Åô„ÄÇ`,
        'color': v => `ÊñáÂ≠óËâ≤„ÅØ **${getColorName(v)}** „Åß„Åô„ÄÇ`,
        'background': v => `ËÉåÊôØ„ÅØ **${getColorName(v)}** „ÅßÂΩ©„Çâ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ`,
        'fill': v => `Â°ó„Çä„Å§„Å∂„Åó„ÅØ **${getColorName(v)}** „Åß„Åô„ÄÇ`,
        'text-decoration': v => v === 'none' ? "‰∏ãÁ∑ö„ÅØÈùûË°®Á§∫„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ" : `Ë£ÖÈ£æ„ÅØ **${v}** „Åß„Åô„ÄÇ`,
        'font-size': v => `ÊñáÂ≠ó„Çµ„Ç§„Ç∫„ÅØ **${v}** „Åß„Åô„ÄÇ`,
        'font-weight': v => parseInt(v) >= 500 ? "ÊñáÂ≠ó„ÅØÂ∞ë„ÅóÂ§™„ÇÅ„ÅÆ„Çà„ÅÜ„Åß„Åô„ÄÇ" : `Â§™„Åï„ÅØ **${v}** „Åß„Åô„ÄÇ`,
        'max-width': v => `ÊúÄÂ§ßÂπÖ„ÅØ **${v}** „Åß„Åô„ÄÇ`,
        'margin-bottom': v => `‰∏ã„Å∏„ÅÆ‰ΩôÁôΩ(Â§ñÈÉ®)„ÅØ **${v}** „Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ`,
        'align-items': v => v === 'center' ? "‰∏¶„Å≥Êñπ„ÅØÁúü„Çì‰∏≠ÂØÑ„Åõ„Åß„Åô„ÄÇ" : `Êï¥Âàó„ÅØ **${v}** „Åß„Åô„ÄÇ`,
        'border': v => v === 'none' ? "Êû†Á∑ö„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ" : `Êû†Á∑ö„ÅØ **${v}** „Åß„Åô„ÄÇ`,
        'position': (v, all) => {
            let res = `ÈÖçÁΩÆ„ÅÆÂü∫Ê∫ñ„Çí **${v}** „Å´Âõ∫ÂÆö„Åó„ÄÅ`;
            if (all.bottom) res += `‰∏ã„Åã„Çâ **${all.bottom}**„ÄÅ`;
            if (all.left) res += `Â∑¶„Åã„Çâ **${all.left}**„ÄÅ`;
            if (all.right) res += `Âè≥„Åã„Çâ **${all.right}**„ÄÅ`;
            return res.replace(/„ÄÅ$/, '') + " „ÅÆ‰ΩçÁΩÆ„ÅßË°®Á§∫„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ";
        }
    };

    function update() {
        const css = document.getElementById('cssInput').value;
        const blocks = css.match(/[^{]+\{[^}]+\}/g);
        if (!blocks) {
            document.getElementById('mdOutput').value = "";
            return;
        }

        let mdFull = "# üé® CSS Ëß£Êûê„É¨„Éù„Éº„Éà\n\n";

        mdFull += blocks.map(block => {
            const selector = block.split('{')[0].trim();
            const declsStr = block.split('{')[1].split('}')[0];
            const decls = declsStr.split(';').map(d => d.trim()).filter(d => d);
            
            const all = {};
            decls.forEach(d => {
                const parts = d.split(':');
                if(parts.length < 2) return;
                const p = parts[0].trim();
                const v = parts.slice(1).join(':').trim();
                all[p] = v;
            });

            const cats = { "üìê „É¨„Ç§„Ç¢„Ç¶„Éà„ÉªÈÖçÁΩÆ": [], "üé® Ë¶ñË¶öÂäπÊûú„ÉªË£ÖÈ£æ": [], "‚úçÔ∏è „Çø„Ç§„Éù„Ç∞„É©„Éï„Ç£": [] };
            const used = new Set();

            Object.entries(all).forEach(([p, v]) => {
                if (used.has(p)) return;
                
                let text = dict[p] ? (p === 'position' ? dict[p](v, all) : dict[p](v)) : `\`${p}\` „Çí \`${v}\` „Å´ÊåáÂÆö„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ`;
                
                if (p === 'position') ['top','bottom','left','right'].forEach(k => used.add(k));

                const category = ['display','position','align-items','gap','max-width','margin-bottom'].includes(p) ? "üìê „É¨„Ç§„Ç¢„Ç¶„Éà„ÉªÈÖçÁΩÆ" : 
                                 ['color','background','fill','border','text-decoration'].includes(p) ? "üé® Ë¶ñË¶öÂäπÊûú„ÉªË£ÖÈ£æ" : "‚úçÔ∏è „Çø„Ç§„Éù„Ç∞„É©„Éï„Ç£";
                cats[category].push(text);
            });

            let mdBlock = `## Selector: \`${selector}\` \n\n`;
            for (const [title, lines] of Object.entries(cats)) {
                if (!lines.length) continue;
                mdBlock += `### ${title}\n`;
                lines.forEach(l => mdBlock += `* ${l}\n`);
                mdBlock += `\n`;
            }
            return mdBlock;
        }).join('---\n\n');

        document.getElementById('mdOutput').value = mdFull;
    }

    document.getElementById('cssInput').addEventListener('input', update);
</script>
</body>
</html>